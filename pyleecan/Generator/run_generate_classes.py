# -*- coding: utf-8 -*-
import sys
from os.path import dirname, abspath, normpath, join, realpath, basename, isfile
from os import listdir, remove, system
import json
from datetime import datetime


begin = len(normpath(abspath(join(dirname(__file__), "../.."))))
end = len(normpath(abspath(join(dirname(__file__), ".."))))
MAIN_DIR = dirname(realpath(__file__))

soft_name = MAIN_DIR[begin + 1 : end]
is_log = True  # To add logger related code (get_logger, ...)

# Add the directory to the python path
sys.path.append(MAIN_DIR[:begin])

exec(
    "from "
    + soft_name
    + ".Generator.ClassGenerator.class_generator import generate_class"
)
exec("from " + soft_name + ".Generator.read_fct import read_all")
exec("from " + soft_name + ".definitions import MAIN_DIR, DOC_DIR, INT_DIR")


# List of the main packages (to sort the classes)
PACKAGE_LIST = ["Geometry", "Machine", "Material", "Slot", "Import"]


def generate_code(
    root_path, gen_dict=None, soft_name="pyleecan", is_log=True, class_list=None
):
    """Generate the package Classes code according to doc in root_path

    Parameters
    ----------
    root_path : str
        Path to the main folder of the package
    gen_dict : dict
        Generation dictionary (contains all the csv data)
    soft_name : str
        Name of the software to generate
    is_log : bool
        True to add the log related code (get_logger...)
    class_list : list
        List of class csv path to generate

    Returns
    -------
    None
    """
    CLASS_DIR = join(root_path, "Classes")
    FUNC_DIR = join(root_path, "Functions")
    DOC_DIR = join(root_path, "Generator", "ClassesRef")
    print("Reading classes csv in: " + DOC_DIR)
    print("Saving generated files in: " + CLASS_DIR)

    if class_list is None:
        # Deleting all the previous class
        print("Deleting old class files...")
        for file_name in listdir(CLASS_DIR):
            if file_name[0] != "_":
                remove(join(CLASS_DIR, file_name))
    else:
        # Deleting only given classes in class_list
        class_name_list = list()
        for csv_path in class_list:
            class_name = basename(csv_path)[:-4]
            class_name_list.append(class_name)
            class_path_py = realpath(join(CLASS_DIR, class_name + ".py"))
            if isfile(class_path_py):
                print("Deleting python class file: " + class_path_py)
                remove(class_path_py)

    # A file to import every classes quickly
    import_file = open(join(CLASS_DIR, "import_all.py"), "w")
    import_file.write("# -*- coding: utf-8 -*-\n\n")
    import_file.write('"""File generated by generate_code() - \n')
    import_file.write('WARNING! All changes made in this file will be lost!\n"""\n\n')

    # A file to select the constructor according to a string
    load_file = open(join(FUNC_DIR, "load_switch.py"), "w")
    load_file.write("# -*- coding: utf-8 -*-\n")
    load_file.write('"""File generated by generate_code() - \n')
    load_file.write('WARNING! All changes made in this file will be lost!\n"""\n\n')

    load_file.write("from ..Classes.import_all import *\n\n")
    load_file.write("load_switch = {\n")

    # Read all the csv files
    if gen_dict is None:
        gen_dict = read_all(DOC_DIR, soft_name=soft_name)

    # Generate all the class files (sorted to remove "commit noise")
    for class_name, _ in iter(sorted(list(gen_dict.items()))):
        import_file.write(
            "from ..Classes." + class_name + " import " + class_name + "\n"
        )
        load_file.write('    "' + class_name + '": ' + class_name + ",\n")
        if class_list is None:
            print("Generation of " + class_name + " class")
            generate_class(
                gen_dict, class_name, CLASS_DIR, soft_name=soft_name, is_log=is_log
            )
        else:
            if class_name in class_name_list:
                print("Generation of " + class_name + " class")
                generate_class(
                    gen_dict, class_name, CLASS_DIR, soft_name=soft_name, is_log=is_log
                )

    import_file.close()
    load_file.write("}\n")
    load_file.close()

    print("Generation of load_switch.py")
    print("Generation of import_all.py")

    # Save gen_dict
    class_dict_file = join(CLASS_DIR, "Class_Dict.json")
    with open(class_dict_file, "w") as json_file:
        json.dump(gen_dict, json_file, sort_keys=True, indent=4, separators=(",", ": "))


def run_generate_classes(
    doc_dir=DOC_DIR,
    int_dir=INT_DIR,
    main_dir=MAIN_DIR,
    is_black=True,
    soft_name=soft_name,
    is_log=is_log,
    class_list=None,
):
    """Main function to generate classes"""

    IS_SDT = False
    SDT_PATH = ""  # To fill

    if IS_SDT:
        main_dir = join(SDT_PATH, "SciDataTool")
        doc_dir = join(main_dir, "Generator", "ClassesRef")
        int_dir = join(main_dir, "Generator", "Internal")
        soft_name = "SciDataTool"
        is_log = False

    gen_dict = read_all(
        doc_dir, is_internal=False, in_path=int_dir, soft_name=soft_name
    )

    generate_code(
        main_dir, gen_dict, soft_name=soft_name, is_log=is_log, class_list=class_list
    )

    if is_black:
        # Run black
        try:
            import black

            if class_list is None:
                system('"{}" -m black {}'.format(sys.executable, main_dir))
            else:
                for csv_path in class_list:
                    class_name = basename(csv_path)[:-4]
                    class_path_py = realpath(
                        join(main_dir, "Classes", class_name + ".py")
                    )
                    out = system(
                        '"{}" -m black --quiet {}'.format(sys.executable, class_path_py)
                    )
                    if out == 0:
                        print("Reformatting python class file: " + class_path_py)
                    else:
                        print("Cannot reformat python class file: " + class_path_py)
            if black.__version__.split(".")[0] != "20":
                print("\n############################################")
                print(
                    "WARNING: The official version of black for pyleecan is 20, please update your black version"
                )
                print("############################################\n")
        except ImportError:
            print("/!\\ Please install and run black (version 20) /!\\")
    now = datetime.now()
    print("End at: ", now.strftime("%H:%M:%S"))


if __name__ == "__main__":
    run_generate_classes()
